{% extends "base.html" %}
{% set active = "query" %}
{% block title %}Query — Personal RAG{% endblock %}

{% block content %}
<div class="chat-container">
    <div id="chat-thread" class="chat-thread">
        <div class="chat-welcome">
            <p>Ask anything about your messages. Follow-up questions work — the
            conversation carries context between turns.</p>
        </div>
    </div>

    <div class="chat-input-area">
        <div class="chat-settings">
            <select id="source" title="Source filter">
                <option value="">All sources</option>
                <option value="imessage">iMessage</option>
                <option value="email">Email</option>
            </select>
            <select id="top_k" title="Number of chunks to retrieve">
                <option value="3">Top 3</option>
                <option value="5" selected>Top 5</option>
                <option value="10">Top 10</option>
            </select>
            <button type="button" id="new-chat-btn" class="btn-sm btn-outline" onclick="clearChat()">New chat</button>
        </div>
        <form id="chat-form" onsubmit="return sendMessage(event)">
            <div class="chat-input-row">
                <input type="text" id="q" placeholder="Ask a question or follow up..." autocomplete="off" required>
                <button type="submit" id="send-btn">Send</button>
            </div>
        </form>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
var chatHistory = [];
var seenChunkIds = [];
var isStreaming = false;

function renderMarkdown(text) {
    return DOMPurify.sanitize(marked.parse(text));
}

function scrollToBottom() {
    var thread = document.getElementById('chat-thread');
    thread.scrollTop = thread.scrollHeight;
}

function createEl(tag, cls, text) {
    var el = document.createElement(tag);
    if (cls) el.className = cls;
    if (text) el.textContent = text;
    return el;
}

function addUserMessage(text) {
    var thread = document.getElementById('chat-thread');
    var msg = createEl('div', 'chat-msg chat-msg-user');
    var bubble = createEl('div', 'chat-bubble chat-bubble-user', text);
    msg.appendChild(bubble);
    thread.appendChild(msg);
    scrollToBottom();
}

function addAssistantMessage() {
    var thread = document.getElementById('chat-thread');
    var msg = createEl('div', 'chat-msg chat-msg-assistant');

    var srcBar = createEl('div', 'chat-sources');
    srcBar.style.display = 'none';
    msg.appendChild(srcBar);

    var refPanel = createEl('div', 'source-ref-panel');
    refPanel.style.display = 'none';
    msg.appendChild(refPanel);

    var bubble = createEl('div', 'chat-bubble chat-bubble-assistant');
    msg.appendChild(bubble);

    thread.appendChild(msg);
    scrollToBottom();
    return {sources: srcBar, refPanel: refPanel, bubble: bubble};
}

function renderSourceChips(container, sources, refPanel) {
    container.textContent = '';
    container._refPanel = refPanel;
    var newSources = sources.filter(function(s) { return s.is_new; });
    var priorSources = sources.filter(function(s) { return !s.is_new; });

    function makeChip(s, extraCls) {
        var chip = createEl('span', 'source-chip' + (extraCls ? ' ' + extraCls : ''));
        chip.textContent = s.contact + ' (' + s.source + (s.similarity ? ', ' + s.similarity : '') + ')';
        if (s.id) {
            chip.dataset.chunkId = s.id;
            chip.onclick = function() { toggleChunkDetail(chip, s, refPanel); };
        }
        return chip;
    }

    if (newSources.length > 0) {
        var label = createEl('span', null, 'New: ');
        container.appendChild(label);
        newSources.forEach(function(s) {
            container.appendChild(makeChip(s, ''));
        });
    }
    if (priorSources.length > 0) {
        var sep = createEl('span', 'source-prior-label', (newSources.length ? ' + ' : '') + 'Prior: ');
        container.appendChild(sep);
        priorSources.forEach(function(s) {
            container.appendChild(makeChip(s, 'source-chip-prior'));
        });
    }
    container.style.display = 'block';

    // Accumulate all chunk IDs
    sources.forEach(function(s) {
        if (s.id && seenChunkIds.indexOf(s.id) === -1) {
            seenChunkIds.push(s.id);
        }
    });
}

function toggleChunkDetail(chip, source, refPanel) {
    // If this chip is already active, collapse
    if (chip.classList.contains('source-chip-active')) {
        chip.classList.remove('source-chip-active');
        refPanel.style.display = 'none';
        refPanel.textContent = '';
        return;
    }

    // Deactivate any previously active chip in the same source bar
    var parent = chip.parentElement;
    var prev = parent.querySelector('.source-chip-active');
    if (prev) prev.classList.remove('source-chip-active');

    chip.classList.add('source-chip-active');
    refPanel.style.display = 'block';
    refPanel.textContent = 'Loading\u2026';
    scrollToBottom();

    var headers = {};
    if (typeof AUTH_TOKEN !== 'undefined') {
        headers['Authorization'] = 'Bearer ' + AUTH_TOKEN;
    }
    fetch('/api/chunk/' + source.id, { headers: headers })
        .then(function(r) { return r.json(); })
        .then(function(data) {
            refPanel.textContent = '';
            if (data.text) {
                var pre = createEl('pre', 'source-ref-text', data.text);
                refPanel.appendChild(pre);
            }
            var meta = data.metadata || source.metadata || {};
            if (source.source === 'email' && meta.message_id) {
                var link = createEl('a', 'source-ref-link', 'Open in Mail');
                link.href = 'message://' + encodeURIComponent(meta.message_id);
                link.title = 'Open this email in Mail.app';
                refPanel.appendChild(link);
            }
            scrollToBottom();
        })
        .catch(function(err) {
            refPanel.textContent = 'Failed to load: ' + err.message;
        });
}

function clearChat() {
    chatHistory = [];
    seenChunkIds = [];
    var thread = document.getElementById('chat-thread');
    thread.textContent = '';
    var welcome = createEl('div', 'chat-welcome');
    var p = createEl('p', null,
        'Ask anything about your messages. Follow-up questions work \u2014 the conversation carries context between turns.');
    welcome.appendChild(p);
    thread.appendChild(welcome);
}

function setInputState(streaming) {
    isStreaming = streaming;
    var btn = document.getElementById('send-btn');
    var input = document.getElementById('q');
    btn.disabled = streaming;
    btn.textContent = streaming ? 'Thinking\u2026' : 'Send';
    if (!streaming) input.focus();
}

function sendMessage(e) {
    e.preventDefault();
    if (isStreaming) return false;

    var input = document.getElementById('q');
    var q = input.value.trim();
    if (!q) return false;
    input.value = '';

    var source = document.getElementById('source').value;
    var topK = parseInt(document.getElementById('top_k').value, 10) || 5;

    // Remove welcome message on first query
    var welcome = document.querySelector('.chat-welcome');
    if (welcome) welcome.remove();

    addUserMessage(q);
    setInputState(true);

    var slots = addAssistantMessage();
    var fullAnswer = '';

    var body = JSON.stringify({
        query: q,
        history: chatHistory,
        top_k: topK,
        source: source || null,
        prior_chunk_ids: seenChunkIds
    });

    // Use fetch + ReadableStream since EventSource doesn't support POST
    var headers = {'Content-Type': 'application/json'};
    if (typeof AUTH_TOKEN !== 'undefined') {
        headers['Authorization'] = 'Bearer ' + AUTH_TOKEN;
    }
    fetch('/api/chat/stream', {
        method: 'POST',
        headers: headers,
        body: body
    }).then(function(response) {
        var reader = response.body.getReader();
        var decoder = new TextDecoder();
        var buffer = '';

        function pump() {
            return reader.read().then(function(result) {
                if (result.done) {
                    finish();
                    return;
                }
                buffer += decoder.decode(result.value, {stream: true});
                var lines = buffer.split('\n');
                buffer = lines.pop();  // keep incomplete line in buffer

                lines.forEach(function(line) {
                    if (line.indexOf('data: ') !== 0) return;
                    var payload;
                    try { payload = JSON.parse(line.slice(6)); } catch(e) { return; }

                    if (payload.type === 'sources') {
                        if (payload.data.length > 0) {
                            renderSourceChips(slots.sources, payload.data, slots.refPanel);
                        }
                    } else if (payload.type === 'token') {
                        fullAnswer += payload.data;
                        slots.bubble.innerHTML = renderMarkdown(fullAnswer);
                        scrollToBottom();
                    } else if (payload.type === 'done') {
                        finish();
                    } else if (payload.type === 'error') {
                        slots.bubble.innerHTML = renderMarkdown(fullAnswer + '\n\n' + payload.data);
                        slots.bubble.classList.add('chat-error');
                        finish();
                    }
                });
                return pump();
            });
        }

        var finished = false;
        function finish() {
            if (finished) return;
            finished = true;
            chatHistory.push({role: 'user', content: q});
            if (fullAnswer) {
                chatHistory.push({role: 'assistant', content: fullAnswer});
            }
            setInputState(false);
            scrollToBottom();
        }

        return pump();
    }).catch(function(err) {
        slots.bubble.textContent = 'Connection error: ' + err.message;
        slots.bubble.classList.add('chat-error');
        setInputState(false);
    });

    return false;
}
</script>
{% endblock %}
